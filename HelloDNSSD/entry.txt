
**mDNS/DNS-SD

AndroidはJelly Bean(APIレベル16)でmDNS(Multicast DNS)とDNS-SD(DNS based Service Discovery)をサポートしました。

mDNSとDNS-SDを使えば、DNSサーバーやレジストリサーバーのようなコンフィグレーションサーバーを介することなく、ネットワーク上のホストの名前を解決し、サービスを提供しているホストを自動的に発見することができます。


mDNSとDNS-SDはネットワークの構成作業を簡略、自動化するためのZeroconf技術の主張な要素です。
これらはAppleによるZeroconf実装に含まれ、その実装はBonjourという名前で知られています。
また、その仕様はインターネットドラフトとして以下のURLで公表されています。

http://files.dns-sd.org/draft-cheshire-dnsext-dns-sd.txt


これら機能はandroid.net.nsdパッケージで提供されています。
その主要なクラスはNsdManagerです。
NsdManagerは、サービスの発見と名前解決、その結果を受け取るためのメソッドを提供しています。
さらに、自身で提供するサービスを他のホストに公開するためのメソッドも提供します。

NsdManagerが扱う結果はNsdServiceInfoクラスのオブジェクトとして扱われます。
NsdServiceInfoは次のプロパティを持っています。
-serviceType
-serviceName
-host
-port


***serviceType
serviceTypeはサービスの種類を表す識別子です。
これは例えば、"_ipp._tcp.local."や、"_myservice._udp.local."のようになります。
識別子"."で区切られ、頭から順に、サービスの種類、プロトコル、ドメインを表します。

最初の例ではippがサービスの種類、tcpがプロトコル、localがドメインです。
ippはInternet Printing Protocolの略で、これら既知のサービスの種類は以下のURLで定義されています。

http://www.dns-sd.org/ServiceTypes.html

二番目の例では、myserviceがサービスの種類です。
これは独自のサービスで、開発者が独自のサービスをネットワーク上に公開する場合はこのような既知の
サービスとして定義されていない識別子を使うことになるでしょう。
例えば、ネットワーク対戦が可能なゲームアプリケーション(仮にHungry Birdsとしましょう)を作る場合、ゲームを実行するそれぞれのホストは
"_hungrybirds._tcp.local."という識別子でサービスを公開し、ネットワーク上で同じ識別子のサービスを探して対戦相手にすることでしょう。

***serviceName
続いてserviceNameは、(紛らわしいことに)serviceTypeで識別されるサービスを公開しているホストの名前です。
これは例えば、"Someone's Mac"、"10-0-1-2"といった、ホストコンピュータの名前やIPアドレスなどが使われることでしょう。

***host, port
hostとportは、サービスを公開しているホストのIPアドレスと、サービスを公開しているポートです。
サービスの種類から、そのサービスを公開しているホストを発見し、そのhostとportを取得するまでがmDNS/DNS-SDの領域です。
そこから先、実際にそのホスト(が公開しているポート)に接続して、サービスが定めるプロトコルに従って通信するのは開発者の役目です。


**サービスの公開と検索

mDNS/DNS-SDを使うには２つの手順があります。
一つはサービスの公開、そしてサービスの検索です。
これらは、両方必要な場合もありますし、いずれか片方だけが必要な場合もあり、それはプログラムの役割に依ります。
プログラムが、既知のサービスを利用するクライアントであるなら、必要なのはサービスの検索です。
逆にサービスを提供するサーバーであるなら、必要なのはサービスの公開です。
そして、P2P形式である場合はサービスの公開と検索の両方が必要になるでしょう。

以下にサービスの公開、サービスの検索の順に、その方法を説明します。
プログラムがP2P形式の場合はそれらを組み合わせて使ってください。


**サービスの公開

まずは公開されたサービスを簡単に見られるようにツールを手にいれましょう。
DNS-SDのサイト(http://www.dns-sd.org/)で紹介されているBonjour Browserのようなツールを使うのが楽でしょう。

ツールを手にいれたら、ツールを実行するコンピュータがネットワークに接続されていることを確認してツールを実行してください。
Macを使っているか、同一ネットワークに他のMacや、Bonjourサービスを実行中のその他のコンピューターがある場合は、いくつかのサービスがリストされることでしょう。
そうでない場合でも気にしないでください。これから作成するプログラムを実行すれば、そのサービスがリストされるはずですから。

では、新しくAndroidプロジェクトを作ってください。
android.net.nsdパッケージはJelly Bean(APIレベル16)以降でしか使えないので、APIレベルは16以降にする必要があります。
また、それ以下では実行できないのでminSdkVersionも16以上にしておくと良いでしょう。

そして後で不幸なことが起きないように(アーメン)今のうちに android.permission.INTERNET をマニフェストに追加しておきましょう。


***NsdManagerオブジェクトの取得
まず、ContextのgetSystemService()メソッドを呼び出して、NsdManagerオブジェクトを取得します。

>|java|
    /** The instance of NsdManager */
    NsdManager nsdManager;

    /**
     * Ensure SystemService objects.
     */
    void ensureSystemServices() {
        nsdManager = (NsdManager) getSystemService(NSD_SERVICE);
        if (nsdManager == null) {
            finish();
        }
    }
||<


***サービスの内容を表すNsdServiceInfoオブジェクトの作成
次に、サービスの内容を表すNsdServiceInfoオブジェクトを作成します。
ここでは、サービスの種類としてippを指定していますが、実際のプログラムでは公開するサービスにあった適切な種類を指定してください。

>|java|
    /** The port of this service */
    static final int SERVICE_PORT = 8888;
    /** The type of this service */
    static final String SERVICE_TYPE = "_ipp._tcp.";
    /** The name of this service */
    static final String SERVICE_NAME = Build.MODEL + ' ' + "the pseudo printer";

    /**
     * Allocate ServiceInfo object for register service.
     * 
     * @return
     */
    static NsdServiceInfo allocateServiceInfo() {
        NsdServiceInfo serviceInfo = new NsdServiceInfo();
        serviceInfo.setPort(SERVICE_PORT);
        serviceInfo.setServiceName(SERVICE_NAME);
        serviceInfo.setServiceType(SERVICE_TYPE);
        return serviceInfo;
    }
||<


***registerService()メソッドを呼び出してサービスを公開
最後に、NsdManagerのregisterService()メソッドを呼び出してサービスを公開します。
unregisterService()は、サービスの公開を終了するメソッドです。

>|java|
    /**
     * Register service to mDNS/DNS-SD.
     */
    void registerService() {
        NsdServiceInfo serviceInfo = allocateServiceInfo();
        int protocolType = NsdManager.PROTOCOL_DNS_SD;
        nsdManager.registerService(serviceInfo, protocolType, registrationListener);
    }

    /**
     * Unregister service from mDNS/DNS-SD.
     */
    void unregisterService() {
        if (regstrationListenerRegistered)
            nsdManager.unregisterService(registrationListener);
    }
||<


***RegistrationListenerオブジェクトで結果を受け取る
registrationListenerはRegistrationListenerオブジェクトで、サービス公開の結果を受け取るために使います。

ここでは、特別な処理はしていませんが、もしサービスの公開が失敗した場合はリスナーは登録されず、その状態でunregisterService()を呼び出してしまうとエラーが発生するので、フラグを管理して失敗時はunregisterService()を呼ばないようにします。

>|java|
    /** The flag which the RegstrationListener was registered or not */
    boolean regstrationListenerRegistered;

    /** The RegstrationListener */
    RegistrationListener registrationListener = new NsdManager.RegistrationListener() {
        @Override
        public void onUnregistrationFailed(NsdServiceInfo serviceInfo, int errorCode) {
            Log.w(TAG, format("UnregstrationFailed serviceInfo=%s, errorCode=%d", serviceInfo, errorCode));
        }

        @Override
        public void onServiceUnregistered(NsdServiceInfo serviceInfo) {
            Log.i(TAG, format("ServiceUnregisterd serviceInfo=%s", serviceInfo));
            regstrationListenerRegistered = false;
        }

        @Override
        public void onServiceRegistered(NsdServiceInfo serviceInfo) {
            Log.i(TAG, format("ServiceRegisterd serviceInfo=%s", serviceInfo));
            regstrationListenerRegistered = true;
        }

        @Override
        public void onRegistrationFailed(NsdServiceInfo serviceInfo, int errorCode) {
            Log.w(TAG, format("RegstrationFailed serviceInfo=%s, errorCode=%d", serviceInfo, errorCode));
        }
    };
||<


***アプリケーションの作成
ここでは、Activityの活性化するときにサービスを公開し、非活性化するときにサービスの公開を停止するようアプリケーションを作成しました

>|java|
    // Activity's lifecycle methods.

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        ensureSystemServices();
    }

    @Override
    protected void onResume() {
        super.onResume();
        registerService();
    }

    @Override
    protected void onPause() {
        unregisterService();
        super.onPause();
    }
||<


***結果の確認
コードを実行して結果を確認みましょう。
実行の前にAndroid端末を、ツールと同じWi-Fiネットワークに接続するのを忘れずに。

ツールで、Internet Printing Protocol(_ipp._tcp.local)に"Galaxy Nexus the pseudo printer"のようなサービスが追加されるのが確認できるはずです。
"Galaxy Nexus"の部分はプログラム上でBuild.MODELフィールドの値を使っているので、各自の環境にあわせて読み替えてください。


もうひとつ、このサービスが他のシステムからどのように見えるか確認してみましょう。
Macを使っているなら、システム環境設定から「プリントとスキャン」を開いてください。
次にプリンタの追加を行うために、プリンタのリストの「+」ボタンを押しましょう。

"Galaxy Nexus the pseudo printer"がプリンターとしてリストされていることでしょう。
これは、サービスを公開する時にサービスの種類として"ipp"を使ったからです。
ippは、Macがネットワークプリンタを探すときに使うサービスであるため、プログラムがippを偽ったサービスを公開したため、Macはこれをプリンターだと認識したのです。


以上がサービスの公開の手順です。

サービスの検索はそのうち追記予定です。


